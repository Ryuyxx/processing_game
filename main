final int MAX_BLK = 30;    
final color BCK_COLOR = color(205);  
final color LINE_COLOR = color(189);   
final int GRID_SPACE = 25;  
final int MAKE_TIME = 60*2;   
final int EXIST_TIME = 60*3;

ArrayList <Integer> enemy_hp=new ArrayList<Integer>();

ArrayList<Block> allBlocks = new ArrayList<Block>();   
Player player; 


void setup(){
    size(800,600); 
    player = new Player(width/2, height/2, 30); 
}


void draw( ) {
    drawBackground();
    drawAllBlocks();
    drawPlayer();
    if(frameCount % MAKE_TIME == 0 && allBlocks.size() < MAX_BLK){
        addBlock();
    }
    for(int i=0;i<allBlocks.size();i++){
      //if(){
     // }
    }
}

/*
boolean hitCheck(Bullet bullet, Block block ){
   float dx,dy,dr;
   dx = abs(bullet.x - block.pointX);
   dy = abs(bullet.y - block.pointY);
   dr = bullet.r/2 + block.collisionR;

   return ( sqrt( sq(dx) + sq(dy) ) < dr );
}
*/


void drawBackground(){
    background(BCK_COLOR);
    strokeWeight(1);   

    
    for(int i = 0; i < width /GRID_SPACE; i++){
        stroke(LINE_COLOR);
        line(GRID_SPACE*i, 0, GRID_SPACE * i, height);
    }
    for(int i = 0; i < height /GRID_SPACE; i++){
        stroke(LINE_COLOR);
        line(0, GRID_SPACE*i, width, GRID_SPACE*i);
    }
}

void drawAllBlocks(){
    for(int i = 0; i < allBlocks.size(); i++){
        allBlocks.get(i).display();
    }
}
void drawPlayer(){
    player.display();
}

void addBlock(){
    switch(int(random(4))){
        case 0: allBlocks.add(new Rectangle(random(width), random(height)));break;
        case 1: allBlocks.add(new Triangle(random(width), random(height)));break;
        case 2: allBlocks.add(new Pentagon(random(width), random(height)));break;
        case 3: allBlocks.add(new Hexagon(random(width), random(height)));break;
        default: break;
    }
    enemy_hp.add(100);
    //if(i==5){allBlocks.remove(0);}
}


abstract class Tank {
    protected float x, y;
    protected int r;
    protected float angle;
    protected ArrayList<Bullet> bullets;

    abstract void display();
    abstract void move();
}


class Player extends Tank{

   
    final color FILL_COLOR = color(0,178,225);  
    final color BATTERY_COLOR = color(153); 
    int movementSpeed = 2;  
    int bulletSpeed = 5;    
    int reloadTime = 60;    
    int elapsedTimeAfterFire = 60;  

    
    Player(float x, float y, int r){
        this.x = x;
        this.y = y;
        this.r = r;
        this.bullets = new ArrayList<Bullet>();
    }

    
    int test = 0;
    boolean isBack = true;


    void display(){
        drawBullets();

        stroke(93);
        strokeWeight(3);
        pushMatrix();

        translate(x,y);
        rotate(angle);

        fill(BATTERY_COLOR);
        rect(test,0-r/4,r, r/2,1);

        /*
        if(isBack && test > -5){
             test--;
         }else if(isBack && test <= -5){
             isBack = false;
         }else if(!isBack && test < 0){
             test++;
         }else if(!isBack && test >= 0){
             isBack = true;
         }
         */

        fill(FILL_COLOR);
        ellipse(0,0,r,r);

        popMatrix();

        updateAngle();
        move();
        if(mousePressed && mouseButton == LEFT && player.elapsedTimeAfterFire > player.reloadTime){
            player.shot();
        }
        elapsedTimeAfterFire++;
    }

    void shot(){
        bullets.add(new Bullet(x, y, bulletSpeed, angle, FILL_COLOR));
        elapsedTimeAfterFire = 0;
    }

    void move(){
        float addPos = movementSpeed;
        if((leftKeyDown || rightKeyDown) && (upKeyDown || downKeyDown)){
            addPos = movementSpeed / sqrt(2);
        }
        if(leftKeyDown){
            x -= addPos;
        }
        if(rightKeyDown){
            x += addPos;
        }
        if(upKeyDown){
            y -= addPos;
        }
        if(downKeyDown){
            y += addPos;
        }
    }

    private void updateAngle(){
        this.angle = atan2(mouseY - this.y, mouseX - this.x);
    }

    private void drawBullets(){
        for(int i = 0; i < bullets.size(); i++){
            Bullet bullet = bullets.get(i);
            bullet.display();
            if(!bullet.isExist()){
                bullets.remove(bullet);
            }
        }
    }

}


class Bullet {


    float x, y;
    private float speedX, speedY;
    private int r = 15;   
    private color fillColor;
    private int life;

    Bullet(float x, float y, int speed, float angle, color fillColor){
        this.x = x;
        this.y = y;
        this.speedX = speed * cos(angle);
        this.speedY = speed * sin(angle);
        this.fillColor = fillColor;
        this.life = EXIST_TIME;
    }

    void display(){
        fill(fillColor);
        stroke(93);
        strokeWeight(2);

        ellipse(x,y,r,r);
        move();
        this.life--;
    }
    private void move(){
        x += speedX;
        y += speedY;
    }
    boolean isExist(){
        if(life < 0){
            return false;
        }else{
            return true;
        }
    }

}

boolean leftKeyDown, rightKeyDown, upKeyDown, downKeyDown;
void keyPressed(){
    if(keyCode == 'A'){
        leftKeyDown = true;
    }else if(keyCode == 'D'){
        rightKeyDown = true;
    }else if(keyCode == 'W'){
        upKeyDown = true;
    }else if(keyCode == 'S'){
        downKeyDown = true;
    }
}

void keyReleased(){
    if(keyCode == 'A'){
        leftKeyDown = false;
    }else if(keyCode == 'D'){
        rightKeyDown = false;
    }else if(keyCode == 'W'){
        upKeyDown = false;
    }else if(keyCode == 'S'){
        downKeyDown = false;
    }
}

/*
boolean Check(Block en1, Bullet en2){
          float dx,dy,dr;
          dx= abs(en1.x - en2.x);
          dy = abs(en1.y - en2.y); 
          dr = en1.WIDTHH/2 + en2.r/2;
          
          return ( sqrt( sq(dx) + sq(dy) ) < dr );
        }
*/
abstract class Block {
    protected float x, y;
    protected float angle;
    abstract void display();
}


class Rectangle extends Block {

    final int WIDTH = 30;
    //final int WIDTH = int(random(0,30));
    color fillColor = color(255,232,105);

    Rectangle(float x, float y){
        this.x = x;
        this.y = y;
        this.angle = random(TWO_PI);
    }

    void display(){
      
        fill(fillColor);
        stroke(93);
        strokeWeight(2);

        pushMatrix();

        translate(x,y);
        rotate(angle);
        rect(0,0,WIDTH,WIDTH,1);

        popMatrix();
        
        /*
        if(Check(Block,Bullet)){
          println("HIT");
        }
        */
        //println(HP);
    }

}

class Triangle extends Block {

    final int WIDTH = 20;
    color fillColor = color(252,118,119);

    Triangle(float x, float y){
        this.x = x;
        this.y = y;
        this.angle = random(TWO_PI);
    }

    void display(){
        fill(fillColor);
        stroke(93);
        strokeWeight(2);

        pushMatrix();

        translate(x,y);
        rotate(angle);
        triangle(WIDTH+cos(0),WIDTH*sin(0),WIDTH*cos(TWO_PI/3),WIDTH*sin(TWO_PI/3),WIDTH*cos(TWO_PI/3*2),WIDTH*sin(TWO_PI/3*2));

        popMatrix();
    }

}

class Pentagon extends Block {

    final int WIDTH = 25;
    color fillColor = color(118,141,252);

    Pentagon(float x, float y){
        this.x = x;
        this.y = y;
        this.angle = random(TWO_PI);
    }

    void display(){
        fill(fillColor);
        stroke(93);
        strokeWeight(2);

        pushMatrix();

        translate(x,y);
        rotate(angle);
        beginShape();
        for(int i = 0; i < 5; i++){
            vertex(WIDTH*cos(TWO_PI/5*i), WIDTH*sin(TWO_PI/5*i));
        }
        endShape(CLOSE);

        popMatrix();

    }
}

class Hexagon extends Block {
    final int WIDTH = 30;
    color fillColor = color(46, 204, 113);

    Hexagon(float x, float y){
        this.x = x;
        this.y = y;
        this.angle = random(TWO_PI);
    }
    void display(){
        fill(fillColor);
        stroke(93);
        strokeWeight(2);

        pushMatrix();

        translate(x,y);
        rotate(angle);
        beginShape();
        for(int i = 0; i < 6; i++){
            vertex(WIDTH*cos(TWO_PI/6*i), WIDTH*sin(TWO_PI/6*i));
        }
        endShape(CLOSE);

        popMatrix();

    }
}
